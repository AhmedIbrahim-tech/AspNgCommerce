{"ast":null,"code":"import { isUserTimingAPISupported } from './is-user-timing-api-supported';\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\nimport { isNodeJSEnv } from './is-nodejs-env';\n// Map() is not used in order to decrease the bundle\nlet marksMap = {};\nlet marksObserver = {};\n/**\n * Get the current time based on User Timing API or Date\n *\n * @returns number\n *\n */\nconst getTimeNow = () => isUserTimingAPISupported ? performance.now() : Date.now();\n/**\n * Clear marks and measure of performance event\n *\n * @param markName - Performance marker to be checked\n *\n * @returns void\n *\n */\nconst clear = markName => {\n  marksMap[markName] = undefined;\n  // Removes PerformanceObserver references from memory\n  if (!!marksObserver[markName]) {\n    marksObserver[markName] = undefined;\n  }\n  if (!isUserTimingAPISupported) {\n    return;\n  }\n  // Some versions of NodeJS doesn't support this method\n  if (!isNodeJSEnv) {\n    performance.clearMeasures(markName);\n  }\n  performance.clearMarks(markName);\n};\n/**\n * Start performance measure of event\n *\n * @param markName - Performance marker to be started\n *\n * @returns number\n *\n */\nconst start = markName => {\n  if (isUserTimingAPISupported) {\n    if (isNodeJSEnv && isPerformanceObservableSupported) {\n      // eslint-disable-next-line compat/compat\n      const obs = new PerformanceObserver(list => {\n        marksObserver[markName] = list.getEntries().find(f => f.name === markName);\n        obs.disconnect();\n      });\n      obs.observe({\n        entryTypes: ['measure']\n      });\n    }\n    performance.mark(markName);\n  }\n  marksMap[markName] = getTimeNow();\n};\n/**\n * Finishes performance measure of event and\n * clear marks and measure if applicable\n *\n * @param markName - Performance marker to be checked\n * @param markNameToCompare - Optional mark to compare to\n *\n * @returns PerfMarksPerformanceEntry\n *\n */\nconst end = (markName, markNameToCompare) => {\n  try {\n    const startTime = marksMap[markName];\n    if (!isUserTimingAPISupported) {\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    }\n    // If there's no User Timing mark to be compared with,\n    // the package will create one to be used for better comparison\n    if (!markNameToCompare) {\n      performance.mark(`${markName}-end`);\n    }\n    performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\n    if (isNodeJSEnv) {\n      if (!!marksObserver[markName]) {\n        return marksObserver[markName];\n      }\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    }\n    const entry = performance.getEntriesByName(markName).pop();\n    return entry || {};\n  } catch (e) {\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if something in event loop crashed\n    // in an unexpected place earlier.\n    // Don't pile on with more errors.\n    return {};\n  } finally {\n    // Clear marks immediately to avoid growing buffer.\n    clear(markName);\n    // Clear marks used for comparison in case of it's value was passed\n    // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\n    clear(markNameToCompare || `${markName}-end`);\n  }\n};\n/**\n * Clear all marks and measures of performance event\n *\n * @returns void\n *\n */\nconst clearAll = () => {\n  marksMap = {};\n  marksObserver = {};\n  if (!isUserTimingAPISupported) {\n    return;\n  }\n  // Some versions of NodeJS doesn't support this method\n  if (!isNodeJSEnv) {\n    performance.clearMeasures();\n  }\n  performance.clearMarks();\n};\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };","map":{"version":3,"names":["isUserTimingAPISupported","isPerformanceObservableSupported","isNodeJSEnv","marksMap","marksObserver","getTimeNow","performance","now","Date","clear","markName","undefined","clearMeasures","clearMarks","start","obs","PerformanceObserver","list","getEntries","find","f","name","disconnect","observe","entryTypes","mark","end","markNameToCompare","startTime","duration","entryType","measure","entry","getEntriesByName","pop","e","clearAll"],"sources":["C:/Users/Ahmed Eprahim/Desktop/Mine/AspNgCommerce/lieblings/node_modules/perf-marks/dist/es2020/marks.js"],"sourcesContent":["import { isUserTimingAPISupported } from './is-user-timing-api-supported';\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\nimport { isNodeJSEnv } from './is-nodejs-env';\n// Map() is not used in order to decrease the bundle\nlet marksMap = {};\nlet marksObserver = {};\n/**\n * Get the current time based on User Timing API or Date\n *\n * @returns number\n *\n */\nconst getTimeNow = () => (isUserTimingAPISupported ? performance.now() : Date.now());\n/**\n * Clear marks and measure of performance event\n *\n * @param markName - Performance marker to be checked\n *\n * @returns void\n *\n */\nconst clear = (markName) => {\n    marksMap[markName] = undefined;\n    // Removes PerformanceObserver references from memory\n    if (!!marksObserver[markName]) {\n        marksObserver[markName] = undefined;\n    }\n    if (!isUserTimingAPISupported) {\n        return;\n    }\n    // Some versions of NodeJS doesn't support this method\n    if (!isNodeJSEnv) {\n        performance.clearMeasures(markName);\n    }\n    performance.clearMarks(markName);\n};\n/**\n * Start performance measure of event\n *\n * @param markName - Performance marker to be started\n *\n * @returns number\n *\n */\nconst start = (markName) => {\n    if (isUserTimingAPISupported) {\n        if (isNodeJSEnv && isPerformanceObservableSupported) {\n            // eslint-disable-next-line compat/compat\n            const obs = new PerformanceObserver(list => {\n                marksObserver[markName] = list.getEntries().find(f => f.name === markName);\n                obs.disconnect();\n            });\n            obs.observe({ entryTypes: ['measure'] });\n        }\n        performance.mark(markName);\n    }\n    marksMap[markName] = getTimeNow();\n};\n/**\n * Finishes performance measure of event and\n * clear marks and measure if applicable\n *\n * @param markName - Performance marker to be checked\n * @param markNameToCompare - Optional mark to compare to\n *\n * @returns PerfMarksPerformanceEntry\n *\n */\nconst end = (markName, markNameToCompare) => {\n    try {\n        const startTime = marksMap[markName];\n        if (!isUserTimingAPISupported) {\n            return startTime\n                ? { duration: getTimeNow() - startTime, startTime, entryType: 'measure', name: markName }\n                : {};\n        }\n        // If there's no User Timing mark to be compared with,\n        // the package will create one to be used for better comparison\n        if (!markNameToCompare) {\n            performance.mark(`${markName}-end`);\n        }\n        performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\n        if (isNodeJSEnv) {\n            if (!!marksObserver[markName]) {\n                return marksObserver[markName];\n            }\n            return startTime\n                ? { duration: getTimeNow() - startTime, startTime, entryType: 'measure', name: markName }\n                : {};\n        }\n        const entry = performance.getEntriesByName(markName).pop();\n        return entry || {};\n    }\n    catch (e) {\n        // If previous mark was missing for some reason, this will throw.\n        // This could only happen if something in event loop crashed\n        // in an unexpected place earlier.\n        // Don't pile on with more errors.\n        return {};\n    }\n    finally {\n        // Clear marks immediately to avoid growing buffer.\n        clear(markName);\n        // Clear marks used for comparison in case of it's value was passed\n        // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\n        clear(markNameToCompare || `${markName}-end`);\n    }\n};\n/**\n * Clear all marks and measures of performance event\n *\n * @returns void\n *\n */\nconst clearAll = () => {\n    marksMap = {};\n    marksObserver = {};\n    if (!isUserTimingAPISupported) {\n        return;\n    }\n    // Some versions of NodeJS doesn't support this method\n    if (!isNodeJSEnv) {\n        performance.clearMeasures();\n    }\n    performance.clearMarks();\n};\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}